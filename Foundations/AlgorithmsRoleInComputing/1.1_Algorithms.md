### 1.1-1. Describe your own real-world example that requires sorting. Describe one that requires finding the shortest distance between two points.

**Sorting Example:**
An ecommerce website typically includes a filter menu that allows users to sort and filter products displayed on the site. One essential filtering option is price sorting, which enables customers to arrange products from lowest to highest price or from highest to lowest price. This sorting functionality helps users quickly find products within their budget range.

**Shortest Distance Example:**
GPS navigation systems demonstrate the practical need for finding the shortest distance between two points. When a user wants to travel from point A to point B, the GPS calculates and displays the most efficient route possible, minimizing both travel time and distance to help the user reach their destination quickly.

### 1.1-2. Other than speed, what other measures of efficiency might you need to consider in a real-world setting?

Beyond speed, memory usage is another critical measure of efficiency to consider in real-world applications. You want algorithms to use as little memory as possible to avoid system resource constraints and reduce costs. Additionally, other efficiency measures include:
- Space complexity: How much storage space the algorithm requires
- Scalability: How well the algorithm performs as data size increases
- Network bandwidth: Relevant for distributed systems and web applications

### 1.1-3. Select a data structure that you have seen, and discuss its strengths and limitations.

I have worked with arrays throughout my career. Arrays offer several key strengths: they provide extremely fast and direct access to elements using their index position, and they allow for easy traversal of elements in sequence. Arrays also have predictable memory usage since they store elements in contiguous memory locations.

However, arrays have notable limitations. In many programming languages, arrays have a fixed size that cannot be changed after creation, making them inflexible for dynamic data. Additionally, inserting or deleting elements in the middle of an array requires shifting other elements, which can be time-consuming for large datasets. Arrays also waste memory if not fully utilized and may require recreating the entire structure when modifications are needed.

### 1.1-4. How are the shortest-path and traveling-salesperson problems given above similar? How are they different?

**Similarities:**
Both problems seek to find optimal paths that minimize total distance or cost. They both operate on graphs or networks where nodes represent locations and edges represent connections between them.

**Differences:**
The key difference lies in their computational complexity and constraints. The shortest-path problem (such as finding the route between two specific cities) has efficient algorithms like Dijkstra's algorithm that can solve it in polynomial time. In contrast, the traveling salesperson problem is computationally much harder as it requires visiting every location exactly once and returning to the starting point, making it an NP-hard problem with no known efficient solution for large instances

### 1.1-5. Suggest a real-world problem in which only the best solution will do. Then come up with one in which approximately the best solution is good enough.

**Best Solution Required:**
Space missions need perfect calculations. When sending rockets to space or other planets, the computer programs must be exactly right. Even tiny mistakes can cause the mission to fail, destroy expensive equipment, or make the spacecraft miss its target completely. Since these missions cost millions of dollars and sometimes involve human lives, there's no room for errors, the solution has be perfect.

**Good Enough Solution:**
Antivirus programs are a good example where a pretty good solution works fine. These programs try to find and stop computer viruses, but they don't need to catch every single one. An antivirus that stops 95-98% of viruses while keeping your computer running smoothly is good enough. A perfect antivirus that catches 100% of viruses would probably make your computer too slow to use, so a good-enough solution is actually better than a perfect one.

### 1.1-6. Describe a real-world problem in which sometimes the entire input is available before you need to solve the problem, but other times the input is not entirely available in advance and arrives over time.

**Data tables with pagination** provide a good example of this problem.
Sometimes you have all the data available right away, for instance, when displaying a small list of 20 customer records, the website can load and show all of them at once. You can sort, filter, or search through the complete dataset immediately. Other times, the input arrives gradually over time, when dealing with thousands of customer records, the website might only load the first 50 records initially. When you click "Next Page" or scroll down, the system fetches and displays the next batch of records. In this case, you can't perform operations on the complete dataset until all pages have been loaded, and some functions (like getting an exact total count) might not work until more data arrives. This happens because loading huge amounts of data all at once would make the website slow and use too much memory, so the system loads data in smaller chunks as needed.
